	PP -> {TS := CreaTabla(); despl := 0}:100
	      P {LiberaTabla(TS), Pop(1)}:101   						//// 1
	P -> B P {}														//// 2
	P -> F P {}														//// 3
	P -> lambda 													//// 4
	B -> if ( E ) S	{B.tipo := if E.tipo = logico
			 then S.tipo else tipo_error; Pop(5)}:102				//// 5
	B -> let {zona_decl := true}:103 id {zona_decl := false}:104
	     T ; {B.tipo := if
		  AnadirTipo(id.pos, T.tipo) then tipo_ok
		  else tipo_error; Pop(4)}:105								//// 6
	B -> for ( M1 ; E ; M2 ) { {C.tipo := vacio}:106
		  C } {B.tipo := if
		  E.tipo = logico && M1.tipo = tipo_ok && M2.tipo = tipo_ok
		  then tipo_ok
          else tipo_error, Pop(11)}:107								//// 7
	B -> {S.tipo := B.tipo}:108 S {B.tipo := S.tipo; Pop(1)}:109	//// 8
	M -> id N E {M.tipo = if
		  BuscaTipo(id.pos) = E.tipo = N.tipo = entero
		  then tipo_ok
		  else tipo_error; Pop(3)}:110								//// 9
	M -> lambda {M.tipo := tipo_ok}:111 							//// 10
	N -> %= {N.tipo := entero; Pop(1)}:112							//// 11
	N -> = {N.tipo := tipo_ok; Pop(1)}:113							//// 12
	T -> int {T.tipo := entero; Pop(1)}:114							//// 13		
	T -> boolean {T.tipo := logico; Pop(1)}:115						//// 14
	T -> string {T.tipo := cadena; Pop(1)}:116						//// 15
	S -> print E ; {S.tipo := if E.tipo = entero ||
		  E.tipo = cadena then tipo_ok
                  else tipo_error; Pop(3)}:117						//// 16
	S -> input id ;	{S.tipo := if
                  BuscaTipo(id.pos) = cadena || entero
                  then tipo_ok
				  else if BuscaTipo(id.pos) = logico
				  then tipo_error
				  else AnadirTipo(id.pos, entero); Pop(3)}:118			//// 17
	S -> return X ; {S.tipo := if
		  !ExisteTSL() then tipo_error
		  else if X.tipo != tipo_error then tipo_ok
		  else tipo_error; Pop(3)}:119								//// 18
	S -> id {W.pos := id.pos}:120 W {S.tipo := W.tipo; Pop(2)}:121	//// 19
	W -> N E ; {W.tipo := if N.tipo = E.tipo = entero
		  then tipo_ok
		  else if BuscaTipo(W.pos) = E.tipo
		  then tipo_ok
		  else tipo_error; Pop(3)}:122								//// 20
	W -> ({L.pos := W.pos}:123 L ) ; {W.tipo := L.tipo; Pop(4)}:124	//// 21
	L -> {E.cont := 1}:125 E {Q.pos := L.pos; Q.tipo := L.tipo
		  Q.cont := E.cont}:126
	     Q {L.tipo := if
	  	  E.tipo = BuscaParam(L.pos, E.cont)
		  && Q.tipo = tipo_ok then tipo_ok
		  else tipo_error; Pop(2)}:127								//// 22
	L -> lambda {}													//// 23
	Q -> , {E.cont := Q.cont++}:128 E
	     {Q1.pos := Q.pos;
	      Q1.cont := E.cont;
	      Q1.tipo := Q.tipo}:129
	     Q1 {Q.tipo := if E.tipo = BuscaParam(Q.pos, E.cont)
		  && Q1.tipo = tipo_ok then tipo_ok
		  else tipo_error; Pop(3)}:130								//// 24
	Q -> lambda {Q.tipo := tipo_ok}:131								//// 25
	X -> E {X.tipo := E.tipo; Pop(1)}:132							//// 26
	X -> lambda {X.tipo := tipo_ok}:133 							//// 27
	F -> function {zona_decl := true}:134
	     id {AnadirTipo(id.pos, funcion),
		 TSL := CreaTabla(), despl = 0}:135
	     H {AnadirParam(id.pos, H.tipo, "TipoRetorno")}:136
             ( {A.cont := 0;
			 	A.pos := id.pos;
				AsignarParam(0, "NumParams")}:137
		 A ) {
			{C.tipo := H.tipo}:138 C {LiberaTablaTSL()}:139
	     } {Pop(9)}:140												//// 28
	H -> T {H.tipo := T.tipo; Pop(1)}:141							//// 29
	H -> lambda {H.tipo := vacio}:142								//// 30
	A -> T id {AnadirTipoTSL(id.pos, T.tipo);
		   AsignarParam(A.pos, A.cont);
		   if T.tipo = entero || logico
			then despl += 1
			else despl += 64;
		   K.pos := A.pos;
		   K.cont := A.cont + 1;
		   AsignarParam(A.cont, "NumParams")}:143 K {Pop(3)}:144					//// 31
	A -> lambda { // crear nueva regla para añadir la cantidad de params }													//// 32
	K -> , T id {AnadirTipoTSL(id.pos, T.tipo);
		     AsignarParam(K.pos, K.cont);
		     if T.tipo = entero || logico
			  then despl += 1
			  else despl += 64;
		   K1.pos := K.pos;
		   K1.cont := K.cont + 1;
		   AsignarParam(K.cont, "NumParams")}:145 K1 {Pop(4)}:146				//// 33
	K -> lambda { // crear nueva regla para añadir la cantidad de params }												//// 34
	C -> {B.tipo := C.tipo}:147 B
	     {C1.tipo := C.tipo}:148 C1 {Pop(2)}:149 											//// 35
	C -> lambda {}													//// 36
	E -> R {Y.tipo := R.tipo}:150 Y {E.tipo := if
		Y.tipo = logico then logico
		else R.tipo; Pop(2)}:151									//// 37
	Y -> != R {Y1.tipo := if
             R.tipo = Y.tipo = entero then logico
	     else tipo_error}:152 Y1 {Y.tipo = Y1.tipo; Pop(3)}:153		//// 38
	Y -> lambda {}													//// 39
	R -> U {Z.tipo := U.tipo}:154 Z {R.tipo := if
	     Z.tipo = entero then entero
             else Z.tipo; Pop(2)}:155								//// 40
	Z -> % U {Z1.tipo := if
	     U.tipo = Z.tipo = entero then entero
	     else tipo_error}:156 Z1 {Z.tipo = Z1.tipo; Pop(3)}:157		//// 41
	Z -> lambda {}													//// 42
	U -> ! V {U.tipo := if V.tipo = logico
	     then logico else tipo_error; Pop(2)}:158					//// 43
	U -> V {U.tipo := V.tipo; Pop(1)}:159							//// 44
	V -> id {J.pos := id.pos; J.tipo :=
	     if BuscaTipo(id.pos) = null then entero
	     else BuscaTipo(id.pos)}:160
	     J {V.tipo := if
	     BuscaTipo(J.pos) = null then entero
	     else BuscaTipo(id.pos); Pop(2)}:161						//// 45
	V -> ( E ) {V.tipo := E.tipo; Pop(3)}:162						//// 46
	V -> ent {V.tipo := entero; Pop(1)}:163 						//// 47
	V -> cad {V.tipo := cadena; Pop(1)}:164							//// 48
	J -> ( {L.pos := J.pos; L.tipo := J.tipo}:165 L )
	     {J.tipo := if
	     L.tipo = tipo_ok then ConsultarTipoRetorno(J.pos)
	     else tipo_error; Pop(3)}:166								//// 49
	J -> lambda {}													//// 50
